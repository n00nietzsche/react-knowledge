# 들어가기 전에

- 이 포스팅은 https://itnext.io/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436 에 있는 포스팅을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://itnext.io/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436 If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche
    
> 리액트 지식 정리 #6, 리액트에서 JWT 토큰과 Passport.js 구현하기

![JWTImage.png](https://images.velog.io/post-images/jakeseo_me/a6420250-6835-11e9-ae5a-876b6fa82653/JWTImage.png)

이미 인터넷에는 JWT사용법을 설명하는 많은 MERN(MongoDB, Express, React, Nodejs)스택 튜토리얼들이 존재합니다. 하지만 그 튜토리얼들이 설명하지 않고 이 포스팅에서만 커버하는 부분이 있습니다.

> 왜, 어떻게 Passport는 passport-jwt를 포함하여 이렇게 다양한 인증방식을 제공하는가?

계속 몇시간동안이나 계속 유저 등록 어플리케이션을 만들어왔습니다.

여러분의 경험이 어땠는지는 모릅니다 하지만 제가 회사에서 일했던 프로젝트들의 대부분은 인증 부분이 이미 누군가에 의해 구현됐었습니다. 이번 포스팅은 MERN 스킬을 더욱 증진시키는 것 외에도 보안과 인증 그리고 이를 위한 다른 방법들에 대해 더 많이 배울 수 있는 기회일 것입니다.

이 포스팅은 주로 어떻게 서버사이드에서 Passport와 JWT를 구현하는가에 대해 다룰 것입니다. 왜냐하면 MAGIC은 거기서 일어나기 때문입니다. 하지만 만일 원한다면, 소스 코드와 만든 MERN 프로젝트의 모든 파일들을 [여기](https://github.com/paigen11/mysql-registration-passport)에서 확인할 수 있습니다. 일단 백엔드에서 제대로 연결이 되면, 프론트엔드는 순수하게 리액트입니다.

배우기 전에, JWT와 Passport.js 인증에 대해 간단히 알아봅시다.

# JSON Web Token이란 무엇인가?

![JWT.png](https://images.velog.io/post-images/jakeseo_me/a2b2af20-6837-11e9-8886-e9922fbbec14/JWT.png)

JSON Web Token의 공식 사이트의 설명은 다음과 같습니다.

> "JSON 객체로써 파티들(Parties) 사이에서 안전하게 정보를 전송하기 위해 간단하고 독립적인 방법을 정의하는 공개된 표준([RFC7519](https://tools.ietf.org/html/rfc7519)) - JWT.io

본질적으로, JWT는 디지털적으로 인증된 확인 가능하고 믿을 수 있는 토큰입니다. 그리고 파티(parties(server-client 같은 것)) 사이에서 보안과 인증을 위해 그리고 토큰이 변조되거나 디코딩되지 않았는지 확인하는 동안 나오는 민감한 정보의 보안을 위해 더욱 인기가 많아지고 있습니다. 

토큰이 어떻게 동작하는지 상세히 기술하진 않을 것입니다. 그건 더욱 신뢰할 수 있는 소스인 [여기](https://jwt.io/introduction/)에서 확인하세요. 하지만 어플리케이션을 만들 때, 간단한 유저 등록을 만들기 위해 Passport.js와 함께 유저 등록의 strategy로 JWT를 사용했다는 것은 말할 수 있습니다. (왜냐하면 구현을 하기 위해 이렇게 많은 작업을 했던 경험이 없어서 제가 진짜로 할 수 있는지 궁금했거든요.)

이정도까지 알아보고, 인증 솔루션을 알아봅시다. 다음 부분은 Passport.js입니다.

# Passport.js 는 무엇이고 왜 사용해야 하는가

![passport.jslogo.png](https://images.velog.io/post-images/jakeseo_me/0e11c3f0-6892-11e9-93a2-2dd137f4fb69/passport.jslogo.png)

Passport는

> Node.js를 위한 간단하고, 무겁지 않은(unobtrusive) 인증입니다.

그리고 Passport.js는 Express와 함께 매우 잘 동작합니다. Passport는 노드를 위한 인증 미들웨어입니다. 모든 다른 기능은 어플리케이션 자체에 보내고 모듈 단위에서 요청을 인증하기 위한 목적을 갖고 있습니다. 코드를 더욱 깔끔하게 하고 유지보수를 더욱 쉽게 하고 고려할 부분을 명확히 나눠줍니다.

만일 'JavaScript authentication middleware'혹은 'JavaScript authentication'을 구글 검색창에 타이핑하면 Passport.js가 상위 5위 안에 있습니다. 이 결과는 JavaScript ecosystem에서 Passport.js가 얼마나 많이 쓰이는지 알려줍니다.

Passport.js가 500개 이상의 인증 Stategy(전략)를 제공한다고 말했었나요? 간단하게 유저 이름과 비밀번호로 로그인을 하고싶던 Github, Facebook, oAuth 등등 다른 인증을 쓰고싶던지 상관없이 Passport가 그것을 지원할 것입니다.

인증 strategy를 위해 Passport를 고르는 것은 매우 간단하고 당연한 선택입니다.

사이트의 문서도 꽤 괜찮다고 말하고 싶습니다. [custom callback](http://www.passportjs.org/docs/authorize/)과 같은 부분은 올바르게 이해하려면 좀 더 잘 읽어봐야 하지만요. 

# Express.js와 약간의 React로 구현하기

![expresslogo.png](https://images.velog.io/post-images/jakeseo_me/2d2db710-6894-11e9-be67-81011364c788/expresslogo.png)

이제 재밌는 부분으로 넘어갑시다. Passport.js와 JWT를 Express/Node 어플리케이션 내부에서 구현할까요? 솔직히 말하자면, 이 문제는 저를 한참이나 괴롭혔습니다. 많은 튜토리얼 후에 많은 문서를 다시 정독하고 스택오버플로에 도움을 청한 뒤에, 어느정도 이해를 했고 만족했습니다.

이 앱의 목적 중 하나는 모듈 형태로 만드는 것이라 할 수 있습니다. 추가하고 삭제하는 기능을 매우 간단하게 만드는 것입니다. 그래서 파일 구조를 봤을 때, CRUD 함수에 대한 모든 라우트가 각각의 파일에 구성되어 있다는 것을 한 눈에 알 수 있을 것입니다. 그리고 모든 Passport 인증은 중앙의 파일 하나에서 다뤄진다는 것 또한 쉽게 알 수 있을 것입니다. 어플리케이션 API부분 파일 구조를 봅시다.

**API 파일 트리**

```
root/
├── api/ 
| ├── config 
| | ├── passport.js 
| | ├── jwtConfig.js
| ├── server.js 
| ├── sequelize.js 
| ├── package.json
| ├── models/ 
| | ├── user.js
| ├── routes/ 
| | ├── deleteUser.js 
| | ├── findUsers.js 
| | ├── loginUser.js 
| | ├── registerUser.js
| | ├── updateUser.js
| ├── node-modules/
```

**`Package.json 파일`**


![jwtpackage.png](https://images.velog.io/post-images/jakeseo_me/65a6d940-6895-11e9-be67-81011364c788/jwtpackage.png)
> 딱히 대단한 것은 없습니다: just jsonwebtoken, passport, passport-local and passport-jwt.

몇몇 추가적인 의존성이 있는데 `babel`과 같은 것입니다. ES6 문법을 Node.js app에서 쓰고 싶어서죠. `bcrypt`는 패스워드 해싱을 위해서고 `sequelize`는 MySQL ORM입니다. 하지만 무엇보다 잘 봐둬야 할 것들은 `jsonwebtoken`, `passport`, `passport-local` 그리고 `passport-jwt`입니다. 이 블로그의 필수요소들이죠.

**`Server.js`파일**

설명이 가장 적게 필요한 `server.js` 파일을 처음으로 시작하겠습니다. 이 파일은 순수하게 서버를 시작하기 위해서 존재합니다. app에서 Passport의 사용을 초기화하고 모든 라우트와 client에서 받은 요청들을 파싱하는 부분이 세팅되어 있습니다.

![jwtserverjs.png](https://images.velog.io/post-images/jakeseo_me/68c56c70-6897-11e9-be67-81011364c788/jwtserverjs.png)
> ES6의 import와 const같은 것들이 들어갔지만, passport.initialize()와 routes같은 것들에 집중해주세요.

꽤 직관적이죠? 좋습니다. 다음으로 갑시다.

아마 위의 소스에서 `require('./config/passport);`와 같은 부분을 발견했을지도 모릅니다. 이제 이 부분이 우리가 작성해야 할 부분입니다. JWT와 Passport 설정(configuration)입니다. `config`라는 폴더 내부에 들어갈 것입니다.

**`jwtConfig.js` 파일**

JWT config는 매우 간단합니다. JWT가 인코딩과 디코딩 하기 위해 필요한 secret을 제공합니다. 일반적으로는 Github에 올라가지 않기 위해 `.env`파일에 저장됩니다. 하지만 이번에는 여기에 작성하겠습니다.

![jwtConfig.png](https://images.velog.io/post-images/jakeseo_me/51e76e30-6898-11e9-b599-21c6abfb43af/jwtConfig.png)
> config 폴더 내부에 jwtConfig.js 파일입니다.

**`passport.js` 파일**

Passport 인증을 위한 진짜 설정은 `passport.js`파일입니다.

![passportjssetup.png](https://images.velog.io/post-images/jakeseo_me/8ce6e290-6898-11e9-b599-21c6abfb43af/passportjssetup.png)

한번에 받아들이기엔 너무 많은 코드라는 것을 압니다. 그냥 Passport와 Passport 인증에 대한 routes에 관한 코드만 보고싶다면, 몇가지 요점만 정리된 [여기](https://gist.github.com/paigen11/c72c8c20da9cd440f45025a1b05e5e58)에서 코드를 보세요.

여기서 이뤄지는 Passport 구현은 두가지 타입을 다룰 것입니다. passport-local은 `register` 그리고 `login` 메소드를 위한 것이고, passport-jwt는 `jwt` 메소드를 위한 것입니다.

Passport-local은 유저 이름과 패스워드를 사용하고 Passport-jwt는 유저가 올바른지 확인하기 위해, JWT payload를 사용합니다.

이전에 말했듯이, Express.js를 사용하기 위한 문서는 꽤 잘돼있습니다 하지만 MySQL 데이터베이스와 조합하는 것은 조금 까다롭습니다. 정보는 프론트 엔드에 있는 리액트 클라이언트에서 전달됩니다.

일단 passport-local strategy에 username과 password가 넘겨지면(서버에서 먼저 두가지 입력 값들이 적어도 제대로 입력 됐는지 확인하고 서버로 보내야겠죠?), MySQL ORM인 Sequelize로 해당 username이 데이터베이스에 존재하는지 먼저 체크를 합니다. 만일 `null` 값을 반환한다면, 인증이 실패합니다.(db에 어떤 사용자도 매칭되지 않았을 때). 그리고 일반적으로 추가적인 정보 없이 `401 Unauthorized`가 서버로부터 클라이언트로 반환될 것입니다.

